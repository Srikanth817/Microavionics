Disassembly Listing for Lab6
Generated From:
/Users/svenkataraman/Documents/Lab6.X/dist/default/production/Lab6.X.production.elf
Oct 28, 2020 11:17:43 PM

---  /Users/svenkataraman/Documents/Lab6.X/lab6_orig_2020.c  --------------------------------------------
1:             
2:             /****** ASEN 4/5067 Lab 6 ******************************************************
3:              * Author: YOUR NAME HERE
4:              * Date  : DATE HERE
5:              *
6:              * Updated for XC8
7:              * 
8:              * Description
9:              * On power up execute the following sequence:
10:             *      RD5 ON for 0.5s +/- 10ms then off
11:             *      RD6 ON for 0.5s +/- 10ms then off
12:             *      RD7 ON for 0.5s +/- 10ms then off
13:             * The following then occurs forever:
14:             *      RD4 blinks: 100ms +/- 10ms ON, then 900ms +/- 10ms OFF
15:             *      LCD Displays the following lines:
16:             *          'T=xx.x C'
17:             *          'PT=x.xxV'
18:             *      Where the 'x' is replaced by a digit in the measurement.
19:             *          Temperature data must be calculated / displayed with one digit to
20:             *          the right of the decimal as shown.  The sensor itself can have
21:             *          errors up to +/- 5 degrees Celsius.
22:             *          Potentiometer data must be calculated / displayed with two digits
23:             *          to the right of the decimal as shown.
24:             *          These measurements must be refreshed at LEAST at a frequency of 5Hz.
25:             *      USART Commands are read / executed properly. '\n' is a Line Feed char (0x0A)
26:             *          ASEN 4067:
27:             *              'TEMP\n'     - Transmits temperature data in format: 'XX.XC'
28:             *              'POT\n'      - Transmits potentiometer data in format: X.XXV'
29:             *          ASEN 5067: Same as ASEN 4067, plus two additional commands
30:             *              'CONT_ON\n'  - Begins continuous transmission of data over USART
31:             *              'CONT_OFF\n' - Ends continuous transmission of data over USART
32:             *
33:             *              Continuous transmission should output in the following format:
34:             *                  'T=XX.XC; PT = X.XXV\n'
35:             *      DAC is used to output analog signal onto RA5 with jumper cables. 
36:             *          ASEN 4067:
37:             *              Potentiometer voltage is converted from a digital value to analog 
38:             *              and output on the DAC. 
39:             *          ASEN 5067: 
40:             *              A 0.5 Hz 0-3.3V triangle wave is output on the DAC. 
41:             *******************************************************************************
42:             *
43:             * Program hierarchy 
44:             *
45:             * Mainline
46:             *   Initial
47:             *
48:             * HiPriISR (included just to show structure)
49:             *
50:             * LoPriISR
51:             *   TMR0handler
52:             ******************************************************************************/
53:            
54:            #include <xc.h>
55:            #include "LCDroutinesEasyPic.h"
56:            #include <string.h>
57:            #include <stdio.h>
58:            #include <stdlib.h>
59:            
60:            
61:            #define _XTAL_FREQ 16000000   //Required in XC8 for delays. 16 Mhz oscillator clock
62:            #pragma config FOSC=HS1, PWRTEN=ON, BOREN=ON, BORV=2, PLLCFG=OFF
63:            #pragma config WDTEN=OFF, CCP2MX=PORTC, XINST=OFF
64:            
65:            /******************************************************************************
66:             * Global variables
67:             ******************************************************************************/
68:            const char LCDRow1[] = {0x80,'T','E','S','T','I','N','G','!',0x00};
69:            unsigned int Alive_count = 0;
70:            unsigned int led_max = 2;
71:            unsigned int toggle = 0xFF;
72:            unsigned char alive_times[] = {0x24, 0x46,0xE7, 0x8C};
73:            
74:            /******************************************************************************
75:             * Function prototypes
76:             ******************************************************************************/
77:            void Initial(void);         // Function to initialize hardware and interrupts
78:            void TMR0handler(void);     // Interrupt handler for TMR0, typo in main
79:            
80:            /******************************************************************************
81:             * main()
82:             ******************************************************************************/
83:            void main() {
84:                 Initial();                 // Initialize everything
1288  EC56     CALL 0x10AC, 0
128A  F008     NOP
85:                  while(1) {
86:                    // Sit here for ever
87:                 }
128C  D7FF     BRA 0x128C
88:            }
89:            
90:            /******************************************************************************
91:             * Initial()
92:             *
93:             * This subroutine performs all initializations of variables and registers.
94:             * It enables TMR0 and sets CCP1 for compare, and enables LoPri interrupts for
95:             * both.
96:             ******************************************************************************/
97:            void Initial() {
98:                // Configure the IO ports
99:                TRISD  = 0b00001111;
10AC  0E0F     MOVLW 0xF
10AE  6E95     MOVWF TRISD, ACCESS
100:               LATD = 0;
10B0  0E00     MOVLW 0x0
10B2  6E8C     MOVWF LATD, ACCESS
101:               TRISC  = 0b10010011;
10B4  0E93     MOVLW 0x93
10B6  6E94     MOVWF TRISC, ACCESS
102:               LATC = 0;
10B8  0E00     MOVLW 0x0
10BA  6E8B     MOVWF LATC, ACCESS
103:               
104:               // Configure the LCD pins for output. Defined in LCDRoutines.h
105:               LCD_RS_TRIS   = 0;              // 
10BC  9893     BCF TRISB, 4, ACCESS
106:               LCD_E_TRIS    = 0;
10BE  9A93     BCF TRISB, 5, ACCESS
107:               LCD_DATA_TRIS = 0b11000000;     // Note the LCD is only on the upper nibble
10C0  0EC0     MOVLW 0xC0
10C2  6E93     MOVWF TRISB, ACCESS
108:                                               // The lower nibble is all inputs
109:               LCD_DATA_LAT = 0;           // Initialize LCD data LAT to zero
10C4  0E00     MOVLW 0x0
10C6  6E8A     MOVWF LATB, ACCESS
110:           
111:           
112:               // Initialize the LCD and print to it
113:               InitLCD();
10C8  EC0A     CALL 0x1014, 0
10CA  F008     NOP
114:               DisplayC(LCDRow1);
10CC  0E01     MOVLW 0x1
10CE  6E0C     MOVWF LCDStr, ACCESS
10D0  0E10     MOVLW 0x10
10D2  6E0D     MOVWF 0xD, ACCESS
10D4  EC1E     CALL 0x123C, 0
10D6  F009     NOP
115:               
116:               LATDbits.LATD5 = 1;
10D8  8A8C     BSF LATD, 5, ACCESS
117:               __delay_ms(500);
10DA  0E0B     MOVLW 0xB
10DC  6E19     MOVWF 0x19, ACCESS
10DE  0E26     MOVLW 0x26
10E0  6E18     MOVWF 0x18, ACCESS
10E2  0E5E     MOVLW 0x5E
10E4  2EE8     DECFSZ WREG, F, ACCESS
10E6  D7FE     BRA 0x10E4
10E8  2E18     DECFSZ 0x18, F, ACCESS
10EA  D7FC     BRA 0x10E4
10EC  2E19     DECFSZ 0x19, F, ACCESS
10EE  D7FA     BRA 0x10E4
118:               LATDbits.LATD5 = 0;
10F0  9A8C     BCF LATD, 5, ACCESS
119:               
120:               LATDbits.LATD6 = 1;
10F2  8C8C     BSF LATD, 6, ACCESS
121:               __delay_ms(500);
10F4  0E0B     MOVLW 0xB
10F6  6E19     MOVWF 0x19, ACCESS
10F8  0E26     MOVLW 0x26
10FA  6E18     MOVWF 0x18, ACCESS
10FC  0E5E     MOVLW 0x5E
10FE  2EE8     DECFSZ WREG, F, ACCESS
1100  D7FE     BRA 0x10FE
1102  2E18     DECFSZ 0x18, F, ACCESS
1104  D7FC     BRA 0x10FE
1106  2E19     DECFSZ 0x19, F, ACCESS
1108  D7FA     BRA 0x10FE
122:               LATDbits.LATD6 = 0;
110A  9C8C     BCF LATD, 6, ACCESS
123:               
124:               LATDbits.LATD7 = 1;
110C  8E8C     BSF LATD, 7, ACCESS
125:               __delay_ms(500);
110E  0E0B     MOVLW 0xB
1110  6E19     MOVWF 0x19, ACCESS
1112  0E26     MOVLW 0x26
1114  6E18     MOVWF 0x18, ACCESS
1116  0E5E     MOVLW 0x5E
1118  2EE8     DECFSZ WREG, F, ACCESS
111A  D7FE     BRA 0x1118
111C  2E18     DECFSZ 0x18, F, ACCESS
111E  D7FC     BRA 0x1118
1120  2E19     DECFSZ 0x19, F, ACCESS
1122  D7FA     BRA 0x1118
126:               LATDbits.LATD7 = 0;
1124  9E8C     BCF LATD, 7, ACCESS
127:           
128:               // Initializing TMR0
129:               T0CON = 0b00000101;             // 16-bit, 64x prescaler
1126  0E05     MOVLW 0x5
1128  6ED5     MOVWF T0CON, ACCESS
130:               TMR0L = 0x8C;
112A  0E8C     MOVLW 0x8C
112C  6ED6     MOVWF TMR0, ACCESS
131:               TMR0H = 0xE7;
112E  0EE7     MOVLW 0xE7
1130  6ED7     MOVWF TMR0H, ACCESS
132:           
133:               // Configuring Interrupts
134:               RCONbits.IPEN = 1;              // Enable priority levels
1132  8ED0     BSF RCON, 7, ACCESS
135:               INTCON2bits.TMR0IP = 0;         // Assign low priority to TMR0 interrupt
1134  94F1     BCF INTCON2, 2, ACCESS
136:           
137:               INTCONbits.TMR0IE = 1;          // Enable TMR0 interrupts
1136  8AF2     BSF INTCON, 5, ACCESS
138:               INTCONbits.GIEL = 1;            // Enable low-priority interrupts to CPU
1138  8CF2     BSF INTCON, 6, ACCESS
139:               INTCONbits.GIEH = 1;            // Enable all interrupts
113A  8EF2     BSF INTCON, 7, ACCESS
140:           
141:               T0CONbits.TMR0ON = 1;           // Turning on TMR0
113C  8ED5     BSF T0CON, 7, ACCESS
142:           }
113E  0012     RETURN 0
143:           
144:           /******************************************************************************
145:            * HiPriISR interrupt service routine
146:            *
147:            * Included to show form, does nothing
148:            ******************************************************************************/
149:           
150:           void __interrupt() HiPriISR(void) {
151:               
152:           }	// Supports retfie FAST automatically
128E  9224     BCF btemp, 1, ACCESS
153:           
154:           /******************************************************************************
155:            * LoPriISR interrupt service routine
156:            *
157:            * Calls the individual interrupt routines. It sits in a loop calling the required
158:            * handler functions until until TMR0IF and CCP1IF are clear.
159:            ******************************************************************************/
160:           
161:           void __interrupt(low_priority) LoPriISR(void) 
0018  8024     BSF btemp, 0, ACCESS
001A  CFD8     MOVFF STATUS, __pcstackCOMRAM
001C  F001     NOP
001E  CFE8     MOVFF WREG, 0x2
0020  F002     NOP
0022  CFE0     MOVFF BSR, 0x3
0024  F003     NOP
162:           {
163:               // Save temp copies of WREG, STATUS and BSR if needed.
164:               while(1) {
165:                   if( INTCONbits.TMR0IF ) {
0026  A4F2     BTFSS INTCON, 2, ACCESS
0028  D003     BRA 0x30
166:                       TMR0handler();
002A  EC2F     CALL 0x125E, 0
002C  F009     NOP
167:                       continue;
002E  D7FB     BRA 0x26
168:                   }
169:                   // Save temp copies of WREG, STATUS and BSR if needed.
170:                   break;      // Supports RETFIE automatically
171:               }
172:           }
0030  C003     MOVFF 0x3, BSR
0032  FFE0     NOP
0034  C002     MOVFF 0x2, WREG
0036  FFE8     NOP
0038  C001     MOVFF __pcstackCOMRAM, STATUS
003A  FFD8     NOP
003C  9024     BCF btemp, 0, ACCESS
003E  0010     RETFIE 0
173:           
174:           
175:           /******************************************************************************
176:            * TMR0handler interrupt service routine.
177:            *
178:            * Handles Alive LED Blinking via counter
179:            ******************************************************************************/
180:           void TMR0handler() {
181:                   LATD = LATD^0x10;
125E  508C     MOVF LATD, W, ACCESS
1260  0A10     XORLW 0x10
1262  6E8C     MOVWF LATD, ACCESS
182:           
183:                   if(PORTDbits.RD4){
1264  A883     BTFSS PORTD, 4, ACCESS
1266  D006     BRA 0x1274
184:                       TMR0L = 0x46; //900 ms
1268  0E46     MOVLW 0x46
126A  6ED6     MOVWF TMR0, ACCESS
185:                       TMR0H =  0x24;
126C  0E24     MOVLW 0x24
126E  6ED7     MOVWF TMR0H, ACCESS
186:                       INTCONbits.TMR0IF = 0;
1270  94F2     BCF INTCON, 2, ACCESS
1272  0012     RETURN 0
187:                       return;
188:                   }
189:                   TMR0L = 0x8C; //100 ms
1274  0E8C     MOVLW 0x8C
1276  6ED6     MOVWF TMR0, ACCESS
190:                   TMR0H = 0xE7;
1278  0EE7     MOVLW 0xE7
127A  6ED7     MOVWF TMR0H, ACCESS
191:           
192:                      
193:               INTCONbits.TMR0IF = 0;      //Clear flag and return to polling routine
127C  94F2     BCF INTCON, 2, ACCESS
194:           }
0008  8224     BSF btemp, 1, ACCESS
127E  0012     RETURN 0
---  /Users/svenkataraman/Documents/Lab6.X/LCDroutinesEasyPic.c  ----------------------------------------
1:             /******************************************************************************
2:              *
3:              * Author(s): Gabriel LoDolce, Trudy Schwartz
4:              * Author of last change: Cody Charland
5:              * Date of last change: 10/19/2019
6:              * 
7:              * Updated to use XC8 compiler instead of c18
8:              *******************************************************************************
9:              * 
10:             * FileName:        LCDroutinesEasyPic.c
11:             * Dependencies:    xc.h, string.h, LCDroutinesEasyPic.h
12:             * Processor:       PIC18F
13:             * Compiler:        XC8
14:             *
15:             *******************************************************************************
16:             *
17:             * File Description: Implementation file for the LCD routines library
18:             *
19:             ******************************************************************************/
20:            
21:            
22:            #include <xc.h>
23:            #include <string.h>
24:            #include "LCDroutinesEasyPic.h"
25:            
26:            #define _XTAL_FREQ 16000000     //Using 16 MHz oscillator clock
27:            
28:            // LCD initialization string
29:            static const char LCDInitStr_[] = "\x33\x32\x28\x0C\x01\x06";      
30:            /*  0x33 0x32 "wakes up" the LCD and sets it to 4 bit mode (3,3,3 is wake up. 2 sets 4 bit mode)
31:             *  0x28 sets it to 2-line mode with 5x8 dot matrix
32:             *  0x0C turns on display and sets cursor and cursor blinking to off
33:             *  0x01 clear display
34:             *  0x06 assigns cursor moving direction
35:             */
36:            
37:            
38:            /*------------------------------------------------------------------------------
39:             * Public functions intended for the user
40:             -----------------------------------------------------------------------------*/
41:            
42:            /********************************************************************
43:             *     Function Name:   InitLCD 
44:             *     Parameters:      None 
45:             *     Description:     This function initializes the LCD by sending the 
46:             *                      LCDInitStr_ commands. These commands wake up the LCD, 
47:             *                      set it to 4 bit mode, and configure cursor and display
48:             *                      settings. 
49:             *
50:             ********************************************************************/
51:            void InitLCD(void) {
52:            	unsigned char count = 0;
1014  0E00     MOVLW 0x0
1016  6E05     MOVWF count, ACCESS
53:                unsigned char nibble = 0;
54:            	
55:                // Delay 40 ms for the LCD controller to come out of reset
56:            	
57:                __delay_ms(40);
1018  0ED0     MOVLW 0xD0
101A  6E04     MOVWF dest, ACCESS
101C  0ECA     MOVLW 0xCA
101E  2EE8     DECFSZ WREG, F, ACCESS
1020  D7FE     BRA 0x101E
1022  2E04     DECFSZ dest, F, ACCESS
1024  D7FC     BRA 0x101E
58:                
59:            	// Drive RS low for command mode
60:            	LCD_RS_LAT = 0;
1026  988A     BCF LATB, 4, ACCESS
61:            
62:            	// Send Each Byte one nibble at a time until we see the null character
63:            	while( LCDInitStr_[count] != 0x00 ) {
1028  D034     BRA 0x1092
1092  0E0B     MOVLW 0xB
1094  2405     ADDWF count, W, ACCESS
1096  6EF6     MOVWF TBLPTR, ACCESS
1098  6AF7     CLRF TBLPTRH, ACCESS
109A  0E10     MOVLW 0x10
109C  22F7     ADDWFC TBLPTRH, F, ACCESS
109E  0008     TBLRD*
10A0  50F5     MOVF TABLAT, W, ACCESS
10A2  0900     IORLW 0x0
10A4  A4D8     BTFSS STATUS, 2, ACCESS
10A6  D7C1     BRA 0x102A
64:                    LCD_DATA_LAT = 0;
102A  0E00     MOVLW 0x0
102C  6E8A     MOVWF LATB, ACCESS
65:            		LCD_E_LAT = 1;                          // Drive E high
102E  8A8A     BSF LATB, 5, ACCESS
66:                    nibble = 0xF0 & LCDInitStr_[count];     // Mask to get upper nibble of LCD string
1030  0E0B     MOVLW 0xB
1032  2405     ADDWF count, W, ACCESS
1034  6EF6     MOVWF TBLPTR, ACCESS
1036  6AF7     CLRF TBLPTRH, ACCESS
1038  0E10     MOVLW 0x10
103A  22F7     ADDWFC TBLPTRH, F, ACCESS
103C  0008     TBLRD*
103E  50F5     MOVF TABLAT, W, ACCESS
1040  0BF0     ANDLW 0xF0
1042  6E06     MOVWF src, ACCESS
67:                    nibble = nibble>>4;                     // Shift right by 4 to make lower nibble for data ports
1044  3806     SWAPF src, W, ACCESS
1046  0B0F     ANDLW 0xF
1048  6E06     MOVWF src, ACCESS
68:                    LCD_DATA_LAT = nibble | LCD_DATA_PORT;  // Mask the upper nibble to ONLY last four of PORTB(RB3:0)
104A  5006     MOVF src, W, ACCESS
104C  1081     IORWF PORTB, W, ACCESS
104E  6E8A     MOVWF LATB, ACCESS
69:                    LCD_E_LAT = 0;                          // Drive E low so LCD will process input     
1050  9A8A     BCF LATB, 5, ACCESS
70:                    __delay_ms(10);                         // Delay 10ms
1052  0E34     MOVLW 0x34
1054  6E04     MOVWF dest, ACCESS
1056  0EF2     MOVLW 0xF2
1058  2EE8     DECFSZ WREG, F, ACCESS
105A  D7FE     BRA 0x1058
105C  2E04     DECFSZ dest, F, ACCESS
105E  D7FC     BRA 0x1058
71:                    
72:                    LCD_DATA_LAT = 0;
1060  0E00     MOVLW 0x0
1062  6E8A     MOVWF LATB, ACCESS
73:            		LCD_E_LAT = 1;                          // Drive E high
1064  8A8A     BSF LATB, 5, ACCESS
74:                    nibble = 0x0F & LCDInitStr_[count];     // Mask to get lower nibble of LCD string
1066  0E0B     MOVLW 0xB
1068  2405     ADDWF count, W, ACCESS
106A  6EF6     MOVWF TBLPTR, ACCESS
106C  6AF7     CLRF TBLPTRH, ACCESS
106E  0E10     MOVLW 0x10
1070  22F7     ADDWFC TBLPTRH, F, ACCESS
1072  0008     TBLRD*
1074  50F5     MOVF TABLAT, W, ACCESS
1076  0B0F     ANDLW 0xF
1078  6E06     MOVWF src, ACCESS
75:            		LCD_DATA_LAT = nibble | LCD_DATA_PORT;	// Send the lower nibble w/o changing RB4:7
107A  5006     MOVF src, W, ACCESS
107C  1081     IORWF PORTB, W, ACCESS
107E  6E8A     MOVWF LATB, ACCESS
76:                    LCD_E_LAT = 0;                          // Drive E low so LCD will process input
1080  9A8A     BCF LATB, 5, ACCESS
77:            		__delay_ms(10);                         // Delay 10ms
1082  0E34     MOVLW 0x34
1084  6E04     MOVWF dest, ACCESS
1086  0EF2     MOVLW 0xF2
1088  2EE8     DECFSZ WREG, F, ACCESS
108A  D7FE     BRA 0x1088
108C  2E04     DECFSZ dest, F, ACCESS
108E  D7FC     BRA 0x1088
78:                    
79:            		count++;                               
1090  2A05     INCF count, F, ACCESS
80:            	}
81:                 
82:            	LCD_RS_LAT = 1;                             // Drive RS HIGH to exit command mode
10A8  888A     BSF LATB, 4, ACCESS
83:            }
10AA  0012     RETURN 0
84:            
85:            /******************************************************************************
86:             *     Function Name:	DisplayC
87:             *     Parameters:      Pointer to a character array in program memory
88:             *     Description:		This function sends a character array in program memory
89:             *						to the LCD display. Note the first character of the
90:             *						string is the positioning command. The string must
91:             *						also be terminated by the null character
92:             *
93:             ******************************************************************************/
94:            void DisplayC( const char *LCDStr ) {
95:                char temp[10];       // Temporary buffer to store input in
96:                strcpy(temp,LCDStr); // Create copy from program memory to data memory variable temp
123C  0E0E     MOVLW 0xE
123E  6E04     MOVWF dest, ACCESS
1240  0E00     MOVLW 0x0
1242  6E05     MOVWF count, ACCESS
1244  C00C     MOVFF LCDStr, src
1246  F006     NOP
1248  C00D     MOVFF 0xD, count
124A  F007     NOP
124C  EC03     CALL 0x1206, 0
124E  F009     NOP
97:                DisplayV(temp);      // Calling DisplayV function to display temp
1250  0E0E     MOVLW 0xE
1252  6E04     MOVWF dest, ACCESS
1254  0E00     MOVLW 0x0
1256  6E05     MOVWF count, ACCESS
1258  ECA0     CALL 0x1140, 0
125A  F008     NOP
98:            }
125C  0012     RETURN 0
99:            
100:           /******************************************************************************
101:            *     Function Name:	DisplayV
102:            *     Parameters:      Pointer to a character array in data memory
103:            *     Description:		This function sends a character array in data memory
104:            *						to the LCD display. Note the first character of the
105:            *						string is the positioning command. The string must
106:            *						also be terminated by the null character
107:            *
108:            *
109:            ******************************************************************************/
110:           void DisplayV( const char * LCDStr ) {
111:               unsigned char count = 0;
1140  0E00     MOVLW 0x0
1142  6E07     MOVWF count, ACCESS
112:               unsigned char nibble = 0;
113:               
114:               while(LCDStr[count] != 0x00) {
1144  D03B     BRA 0x11BC
115:                   // Transmitting the upper nibble
116:                   LCD_E_LAT = 0;
1146  9A8A     BCF LATB, 5, ACCESS
117:                   LCD_DATA_LAT = LCD_DATA_PORT & 0b11000000;
1148  5081     MOVF PORTB, W, ACCESS
114A  0BC0     ANDLW 0xC0
114C  6E8A     MOVWF LATB, ACCESS
118:                   if(count==0){
114E  5007     MOVF count, W, ACCESS
1150  A4D8     BTFSS STATUS, 2, ACCESS
1152  D002     BRA 0x1158
119:                       LCD_RS_LAT = 0;     // First hex character is a command - cursor location
1154  988A     BCF LATB, 4, ACCESS
120:                   }
1156  D001     BRA 0x115A
121:                   else{  
122:                       LCD_RS_LAT = 1;     // Telling the LCD we are about to transmit DATA!
1158  888A     BSF LATB, 4, ACCESS
123:                   }     
124:                   LCD_E_LAT = 1;
115A  8A8A     BSF LATB, 5, ACCESS
125:                   nibble = 0xF0 & LCDStr[count];
115C  5007     MOVF count, W, ACCESS
115E  2404     ADDWF dest, W, ACCESS
1160  6ED9     MOVWF FSR2, ACCESS
1162  0E00     MOVLW 0x0
1164  2005     ADDWFC count, W, ACCESS
1166  6EDA     MOVWF FSR2H, ACCESS
1168  50DF     MOVF INDF2, W, ACCESS
116A  0BF0     ANDLW 0xF0
116C  6E06     MOVWF src, ACCESS
126:                   nibble = nibble >> 4;
116E  3806     SWAPF src, W, ACCESS
1170  0B0F     ANDLW 0xF
1172  6E06     MOVWF src, ACCESS
127:                   LCD_DATA_LAT = nibble | LCD_DATA_PORT;
1174  5006     MOVF src, W, ACCESS
1176  1081     IORWF PORTB, W, ACCESS
1178  6E8A     MOVWF LATB, ACCESS
128:                   LCD_E_LAT = 0;
117A  9A8A     BCF LATB, 5, ACCESS
129:                   __delay_us(50);         // Delay to allow LCD to display char 50 us delay
117C  0E42     MOVLW 0x42
117E  2EE8     DECFSZ WREG, F, ACCESS
1180  D7FE     BRA 0x117E
1182  D000     BRA 0x1184
130:           
131:                   // Transmitting the lower nibble
132:                   LCD_DATA_LAT = LCD_DATA_PORT & 0b11000000;
1184  5081     MOVF PORTB, W, ACCESS
1186  0BC0     ANDLW 0xC0
1188  6E8A     MOVWF LATB, ACCESS
133:                   if(count==0){
118A  5007     MOVF count, W, ACCESS
118C  A4D8     BTFSS STATUS, 2, ACCESS
118E  D002     BRA 0x1194
134:                       LCD_RS_LAT = 0;     // First hex character is a command - cursor location 
1190  988A     BCF LATB, 4, ACCESS
135:                   }
1192  D001     BRA 0x1196
136:                   else{  
137:                       LCD_RS_LAT = 1;     // Telling the LCD we are about to transmit DATA!
1194  888A     BSF LATB, 4, ACCESS
138:                   }   
139:                   LCD_E_LAT = 1;
1196  8A8A     BSF LATB, 5, ACCESS
140:                   nibble = 0x0F & LCDStr[count];
1198  5007     MOVF count, W, ACCESS
119A  2404     ADDWF dest, W, ACCESS
119C  6ED9     MOVWF FSR2, ACCESS
119E  0E00     MOVLW 0x0
11A0  2005     ADDWFC count, W, ACCESS
11A2  6EDA     MOVWF FSR2H, ACCESS
11A4  50DF     MOVF INDF2, W, ACCESS
11A6  0B0F     ANDLW 0xF
11A8  6E06     MOVWF src, ACCESS
141:                   LCD_DATA_LAT = nibble | LCD_DATA_PORT;
11AA  5006     MOVF src, W, ACCESS
11AC  1081     IORWF PORTB, W, ACCESS
11AE  6E8A     MOVWF LATB, ACCESS
142:                   LCD_E_LAT = 0;
11B0  9A8A     BCF LATB, 5, ACCESS
143:                   __delay_us(50);        // Delay to allow LCD to display char 50 us delay
11B2  0E42     MOVLW 0x42
11B4  2EE8     DECFSZ WREG, F, ACCESS
11B6  D7FE     BRA 0x11B4
11B8  D000     BRA 0x11BA
144:                   
145:           
146:                   count++;
11BA  2A07     INCF count, F, ACCESS
147:               }
11BC  5007     MOVF count, W, ACCESS
11BE  2404     ADDWF dest, W, ACCESS
11C0  6ED9     MOVWF FSR2, ACCESS
11C2  0E00     MOVLW 0x0
11C4  2005     ADDWFC count, W, ACCESS
11C6  6EDA     MOVWF FSR2H, ACCESS
11C8  50DF     MOVF INDF2, W, ACCESS
11CA  B4D8     BTFSC STATUS, 2, ACCESS
11CC  0012     RETURN 0
11CE  D7BB     BRA 0x1146
148:           } 
0018  8024     BSF btemp, 0, ACCESS
149:           
---  /Applications/microchip/xc8/v2.05/pic/sources/c99/common/strcpy.c  ---------------------------------
1:             #include <string.h>
2:             
3:             #ifndef __XC8__
4:             char *__stpcpy(char *, const char *);
5:             #endif
6:             
7:             char *strcpy(char *restrict dest, const char *restrict src)
8:             {
9:             #ifndef __XC8__
10:            	__stpcpy(dest, src);
11:            	return dest;
12:            #else
13:            	const char *s = src;
1206  C006     MOVFF src, s
1208  F008     NOP
120A  C007     MOVFF count, 0x9
120C  F009     NOP
14:            	char *d = dest;
120E  C004     MOVFF dest, d
1210  F00A     NOP
1212  C005     MOVFF count, 0xB
1214  F00B     NOP
15:            	while ((*d++ = *s++));
1216  C008     MOVFF s, TBLPTR
1218  FFF6     NOP
121A  C009     MOVFF 0x9, TBLPTRH
121C  FFF7     NOP
121E  4A08     INFSNZ s, F, ACCESS
1220  2A09     INCF 0x9, F, ACCESS
1222  C00A     MOVFF d, FSR2
1224  FFD9     NOP
1226  C00B     MOVFF 0xB, FSR2H
1228  FFDA     NOP
122A  4A0A     INFSNZ d, F, ACCESS
122C  2A0B     INCF 0xB, F, ACCESS
122E  0008     TBLRD*
1230  CFF5     MOVFF TABLAT, INDF2
1232  FFDF     NOP
1234  50DF     MOVF INDF2, W, ACCESS
1236  B4D8     BTFSC STATUS, 2, ACCESS
1238  0012     RETURN 0
123A  D7ED     BRA 0x1216
16:            	return dest;
17:            #endif
18:            }
